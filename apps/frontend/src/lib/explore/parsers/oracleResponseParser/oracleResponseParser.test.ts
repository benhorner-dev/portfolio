import { beforeEach, describe, expect, it, vi } from "vitest";
import { defaultAnswerFormatter } from "@/lib/explore/parsers/oracleResponseParser";
import type { AgentAction } from "@/lib/explore/types";

vi.mock("@/lib/logger", () => ({
	getLogger: vi.fn(() => ({
		info: vi.fn(),
		error: vi.fn(),
		warn: vi.fn(),
		debug: vi.fn(),
	})),
}));

describe("defaultAnswerFormatter", () => {
	const errorMessage =
		"## Error\n\nNo final answer was generated. Please try again.\n\n---\n*Generated by Nexties*";

	beforeEach(() => {
		vi.clearAllMocks();
	});
	it("should return error message when final_answer action index is not found", () => {
		const mockStep = {
			actions: [
				{
					tool: "final_answer",
					toolInput: { answer: "test answer" },
				},
			],
			results: ["some result"],
		};

		const originalFindIndex = Array.prototype.findIndex;
		Array.prototype.findIndex = vi.fn().mockReturnValueOnce(-1);

		const result = {
			intermediateSteps: [mockStep],
		};

		expect(defaultAnswerFormatter(result)).toBe(errorMessage);

		Array.prototype.findIndex = originalFindIndex;
	});
	it("should return error message when intermediate_steps is null or undefined", () => {
		const result1 = {};
		expect(defaultAnswerFormatter(result1)).toBe(errorMessage);

		const result2 = { intermediateSteps: null };
		expect(defaultAnswerFormatter(result2)).toBe(errorMessage);
	});

	it("should return error message when intermediate_steps is empty", () => {
		const result = { intermediateSteps: [] };
		expect(defaultAnswerFormatter(result)).toBe(errorMessage);
	});

	it("should return error message when no final_answer step is found", () => {
		const mockAction: AgentAction = {
			tool: "some_other_tool",
			toolInput: {},
		} as any;

		const result = {
			intermediateSteps: [{ actions: [mockAction], results: ["some output"] }],
		};

		expect(defaultAnswerFormatter(result)).toBe(errorMessage);
	});

	it("should use tool input as fallback when output is empty or whitespace", () => {
		const mockAction: AgentAction = {
			tool: "final_answer",
			toolInput: {
				answer: "fallback answer",
				researchSteps: "fallback research steps",
			},
		} as any;

		const result1 = {
			intermediateSteps: [{ actions: [mockAction], results: [""] }],
		};

		const result2 = {
			intermediateSteps: [{ actions: [mockAction], results: ["   "] }],
		};

		const result3 = {
			intermediateSteps: [{ actions: [mockAction], results: [null] }],
		};

		const expectedOutput = `## Answer
fallback answer
## Thoughts
fallback research steps
---
*Generated by Nexties*`;

		expect(defaultAnswerFormatter(result1)).toBe(expectedOutput);
		expect(defaultAnswerFormatter(result2)).toBe(expectedOutput);
		expect(defaultAnswerFormatter(result3)).toBe(expectedOutput);
	});

	it("should parse valid JSON output and return formatted answer", () => {
		const mockAction: AgentAction = {
			tool: "final_answer",
			toolInput: {
				answer: "fallback answer",
				researchSteps: "fallback steps",
			},
		} as any;

		const jsonOutput = JSON.stringify({
			answer: "parsed answer from JSON",
			researchSteps: "parsed research steps from JSON",
		});

		const result = {
			intermediateSteps: [{ actions: [mockAction], results: [jsonOutput] }],
		};

		const expectedOutput = `## Answer
parsed answer from JSON
## Thoughts
parsed research steps from JSON
---
*Generated by Nexties*`;

		expect(defaultAnswerFormatter(result)).toBe(expectedOutput);
	});

	it("should use tool input as fallback when JSON parsing fails", () => {
		const mockAction: AgentAction = {
			tool: "final_answer",
			toolInput: {
				answer: "fallback answer after JSON error",
				researchSteps: "fallback research steps after JSON error",
			},
		} as any;

		const result = {
			intermediateSteps: [
				{ actions: [mockAction], results: ["invalid json {"] },
			],
		};

		const expectedOutput = `## Answer
fallback answer after JSON error
## Thoughts
fallback research steps after JSON error
---
*Generated by Nexties*`;

		expect(defaultAnswerFormatter(result)).toBe(expectedOutput);
	});
});
